ROS 架构的三个层次：基于 Linux 系统的 OS 层；实现 ROS 核心通信机制以及众多机器人开发库的中间层；在 ROS Master 的管理下保证功能节点的正常运行的应用层。
> OS 层：ROS 并不是真正意义上的 OS，所以需要真正的 OS 来辅助，OS 层应该是处理这部分内容的；
> 中间层：负责节点通信和可以被应用层使用的库；
> 应用层：节点管理和接口。

从系统实现角度将 ROS 划分成的三个层次：计算图、文件系统和开源社区，其中涵盖了 ROS 中的关键概念，如节点、消息、话题、服务、功能包、元功能包等。

ROS 的三种通信机制：基于发布/订阅的话题通信、基于客户端/服务器的服务通信以及基于 RPC 的参数服务器。

![[ROS架构.png]]

1.  OS 层
ROS 并不是一个传统意义上的操作系统，无法像 Windows、Linux 一样直接运行在计算机硬件之上，而是需要依托于 Linux 系统。所以在 OS 层，我们可以直接使用 ROS 官方支持度最好的 Ubuntu 操作系统，也可以使用 macOS、Arch、Debian 等操作系统。
> ROS 并不能直接控制硬件，因此无法充当硬件和软件之间的过渡，也就不是操作系统。

2.  中间层
Linux 是一个通用系统， 并没有针对机器人开发提供特殊的中间件， 所以 ROS 在中间层做了大量工作，其中最为重要的就是基于 TCPROS/UDPROS 的通信系统。ROS 的通信系统基于 TCP/UDP 网络，在此之上进行了再次封装，也就是 TCPROS/UDPROS。通信系统使用发布/订阅、客户端/服务器等模型，实现多种通信机制的数据传输。
除了 TCPROS/UDPROS 的通信机制外，ROS 还提供一种进程内的通信方法——Nodelet，可以为多进程通信提供一种更优化的数据传输方式，适合对数据传输实时性方面有较高要求的应用。
在通信机制之上，ROS 提供了大量机器人开发相关的库，如数据类型定义、坐标变换、运动控制等，可以提供给应用层使用。
> 基于 TCPROS/UDPROS 的通信系统 -> 基于 TCP/UDP 网络，针对 ROS 的通信协议再次封装。
> Nodelet：进程内的通信方法，优化多进程通信。
> 中间层还提供与机器人开发相关的库，提供给应用层。

3.  应用层
在应用层，ROS 需要运行一个管理者——Master，负责管理整个系统的正常运行。ROS 社区内共享了大量的机器人应用功能包，这些功能包内的模块以节点为单位运行，以 ROS 标准的输入输出作为接口，开发者不需要关注模块的内部实现机制，只需要了解接口规则即可实现复用，极大地提高了开发效率。
> ROS Master 管理系统运行，个人认为其角色于类似操作系统的内核。

![[ROS系统实现.png]]

计算图：从计算图的角度来看，ROS 系统软件的功能模块以节点为单位独立运行，可以分布于多个相同或不同的主机中，在系统运行时通过端对端的拓扑结构进行连接。

![[ROS中的节点关系图.png]]

节点（node）是指在 ROS 中运行的最小处理器单元。 可以把它看作一个可执行程序。在 ROS 中，建议为一个目的创建一个节点，设计时注重可重用性。例如，在移动机器人的情况下，为了驱动机器人，将每个程序细分化。也就是说，使用传感器驱动、传感器数据转换、障碍物判断、电机驱动、编码器输入和导航等多个细分节点。
节点在运行的同时，向 ROS Master 注册节点的名称，并且还注册发布者（publisher）、 订阅者（subscriber）、服务服务器（service server）、服务客户端（service client）的名称，且注册消息形式、URI 地址和端口。基于这些信息，每个节点可以使用话题和服务与其他节点交换消息。
节点使用 XMLRPC 与主站进行通信，并使用 TCP/IP 通信系列的 XMLRPC 或 TCPROS 进行节点之间的通信。节点之间的连接请求和响应使用 XMLRPC，而消息通信使用 TCPROS，因为它是节点和节点之间的直接通信，与主节点无关。URI 地址和端口则使用存储于运行当前节点的计算机上的名为 `ROS_HOSTNAME` 的环境变量作为 URI 地址，并将端口设置为任意的固有值。

消息：节点之间最重要的通信机制就是基于发布/订阅模型的消息（Message）通信。节点之间通过消息来发送和接收数据，每一个消息都是一种严格的数据结构，支持标准数据类型（整型、浮点型、布尔型等），也支持嵌套结构和数组（类似于 C 语言的结构体 struct），还可以根据需求由开发者自主定义。
使用消息的通信方法包括 TCPROS， UDPROS 等， 根据情况使用单向消息发送/接收方式的话题（topic）和双向消息请求（request）/ 响应 （response）方式的服务（service）。


![[ROS中基于发布-订阅模型的话题通信.png]]
话题：消息以一种发布/订阅（Publish/Subscribe）的方式传递。一个节点可以针对一个给定的话题（Topic）发布消息（称为发布者/Talker），也可以关注某个话题并订阅特定类型的数据（称为订阅者/Listener）。发布者和订阅者并不了解彼此的存在，系统中可能同时有多个节点发布或者订阅同一个话题的消息。
话题可以看成这样的流程：在发布者节点向 ROS Master 注册某个话题之后，发布者节点以消息形式发布关于该话题的广告，而希望接收该话题的订阅者节点将获得在 ROS Master 中以这个话题注册的那个发布者节点的信息。基于这个信息，订阅者节点直接连接到发布者节点，用话题发送和接收消息。

发布是指以与话题的内容对应的消息的形式发送数据。为了执行发布，发布者节点在 ROS Master 上注册自己的话题等多种信息，并向希望订阅的订阅者节点发送消息。发布者在节点中声明自己是执行发布的个体。单个节点可以成为多个发布者。

订阅是指以与话题内容对应的消息的形式接收数据。为了执行订阅，订阅者节点在 ROS Master 上注册自己的话题等多种信息，并从 ROS Master 接收那些发布此节点要订阅的话题的发布者节点的信息。基于这个信息，订阅者节点直接联系发布者节点来接收消息。订阅者在节点中声明自己执行订阅的个体。单个节点可以成为多个订阅者。

发布和订阅概念中的话题是异步的，这是一种根据需要发送和接收数据的好方法。另外，由于它通过一次连接，发送和接收连续的消息，所以它经常被用于必须**连续**发送消息的传感器数据。然而，在某些情况下，需要一种**共同使用**请求和响应的同步消息交换方案。
因此，ROS 提供叫做服务（service）的消息同步方法。服务分为响应请求的服务服务器和请求后接收响应的服务客户端。与话题不同，服务是一次性的消息通信。当服务的请求和响应完成时，两个节点的连接被断开。

服务：虽然基于话题的发布/订阅模型是一种很灵活的通信模式，但是对于双向的同步传输模式并不适合。 在 ROS 中，我们称这种同步传输模式为服务（Service），其基于客户端/服务器（Client/Server）模型，包含两个部分的通信数据类型：一个用于请求， 另一个用于应答， 类似于 Web 服务器。 与话题不同的是， ROS 中只允许有一个节点提供指定命名的服务。

服务消息通信是客户端与服务器之间的同步双向消息通信。其中客户端请求对应于特定目的任务的服务，而服务器则负责服务响应。

服务服务器：是以请求作为输入，以响应作为输出的服务消息通信的服务器。请求和响应都是消息，服务器收到服务请求后，执行指定的服务，并将结果下发给服务客户端。服务服务器用于执行指定命令的节点。

服务客户端：是以请求作为输出并以响应作为输入的服务消息通信的客户端。请求和响应都是消息，并发送服务请求到服务服务器后接收其结果。服务客户端用于传达给定命令并接收结果值的节点。

动作：是在需要像服务那样的双向请求的情况下使用的消息通信方式，不同点是在处理请求之后需要很长的响应，并且需要中途反馈值。动作文件也非常类似于服务，目标（goal）和结果（result）对应于请求和响应。此外，还添加了对应于中途的反馈（feedback）。它由一个设置动作目标（goal）的动作客户端（action client）和一 个动作服务器（action server），动作服务器根据目标执行动作，并发送反馈和结果。动作客户端和动作服务器之间进行异步双向消息通信。

动作服务器：以从动作客户端接收的目标作为输入并且以结果和反馈值作为输出的消息通信的服务器。在接收到来自客户端的目标值后， 负责执行实际的动作。

动作客户端：是以目标作为输出并以从动作服务器接收待结果和反馈值作为输入的消息通信的客户端。它将目标交付给动作服务器，收到结果和反馈，并给出下一个指示或取消目标。

参数
ROS 中的参数（parameter）是指节点中使用的参数。 可以把它想象成一个 Windows 程序中的 `*.ini` 配置文件。这些参数是默认（default）设置的，可以根据需要从外部读取或写入。尤其是，它可以通过使用外部的写入功能实时更改设置值，因此非常有用。例如，您可以指定与外部设备连接的 PC 的 USB 端口、相机校准值、电机速度或命令的最大值和最小值等设置值。

参数服务器（parameter server）是指在功能包中使用参数时，注册各参数的服务器。参数服务器也是 ROS Master 的一个功能。


catkin：指 ROS 的构建系统。ROS 的构建系统基本上使用 CMake（Cross Platform Make），并在功能包目录中的 `CMakeLists.txt` 文件中描述构建环境。 在 ROS 中， 我们将 CMake 修改成专为 ROS 定制的 catkin 构建系统。catkin 从 ROS Fuerte 版本开始进行 alpha 测试，并从 Groovy 版本开始核心功能包转换为 catkin，且从 Hydro 版本开始应用 于大部分功能包。catkin 构建系统让用户方便使用与 ROS 相关的构建、功能包管理以及功能包之间的依赖关系等。现在使用 ROS 的话，需要使用 catkin 而不是 rosbuild。

roscore：roscore 是运行 ROS Master 的命令。也可以在另一台位于同一个网络内的计算机上运行它。但是，除了支持多 roscore 的某些特殊情况，roscore 在一个网络中只能运行一个。运行 ROS 时，将使用您在 `ROS_MASTER_URI` 变量中列出的 URI 地址和端口。如果用户没有设置，会使用当前本地 IP 作为 URI 地址并使用端口11311。

rosrun：rosrun 是 ROS 的基本运行命令。它用于在功能包中运行一个节点。节点使用的 URI 地址将存储在当前运行节点的计算机上的 `ROS_HOSTNAME` 环境变量作为 URI 地址，端口被设置为任意的固有值。

roslaunch：如果 rosrun 是执行一个节点的命令，那么 roslaunch 是运行多个节点的概念。该命令允许运行多个确定的节点。其他功能还包括一些专为执行具有诸多选项的节点的 ROS 命令，比如包括更改功能包参数或节点名称、配置节点命名空间、设置 `ROS_ROOT` 和 `ROS_ PACKAGE_PATH` 以及更改环境变量等。roslaunch 使用 `*.launch` 文件来设置可执行节点，它基于可扩展标记语言（XML）， 并提供 XML 标记形式的多种选项。

bag：用户可以保存 ROS 中发送和接收的消息的数据， 这时用于保存的文件格式称为 bag ，是以 `*.bag` 作为扩展名。在 ROS 中，这个功能包可以用来存储信息并在需要时可以回放以前的情况。例如，当使用传感器执行机器人实验时，使用bag 将传感器值以消息形式保存。有了这些保存的信息，即使不重复执行之前的实验，也能通过回放保存的 bag 文件来反复利用当时的传感器值。特别的，如果利用 rosbag 的记录和回放功能，在开发那些需要反复修改程序的算法的时候会非常有用。

ROS Wiki：ROS 的基本说明是一个基于 wiki 的[页面](http://wiki.ros.org/)，它解释了 ROS 提供的每个功能包和功能。这个维基页面描述了 ROS 的基本用法、每个功能包的简要说明、用到的参数、作者、许可证、主页、存储库和教程等内容。目前，ROS Wiki 拥有超过 17,000 页的内容。

存储库：每一个公开的功能包都会在该功能包的 wiki 上指定一个存储库（repository）。 存储库是存储功能包的网站的URL 地址，并使用源代码管理系统（如 svn、hg 和 git）来管理问题、开发、下载等。许多当前可用的 ROS 功能包将 github 用作存储库。如果您对每个功能包的源代码内容感兴趣，则可以在相应的存储库中进行查阅。

状态图：上面描述的节点、话题、发布者和订阅者之间关系可以通过状态图（graph）直观地表示。它是当前正在运行的消息通信的图形表示。但不能为一次性服务创建状态图。执行它是通过运行 `rqt_graph` 功能包的 `rqt_graph` 节点完成的。有两种执行命令：`rqt_graph` 和 `rosrun rqt_graph rqt_graph`。

名称：节点、参数、话题和服务都有名称（name） 。当使用节点的参数、话题和服务时，向 ROS Master 注册该名称并根据名称进行搜索，然后发送消息。此外，名称非常灵活，因为它们可以在运行时被更改。另外，对于一个节点、参数、话题和服务，也能给其设定多个不同的名称。这种取名规则使得 ROS 适用于大型项目和复杂系统。

客户端库：ROS 是一个客户端库（client library），它为各种语言提供开发环境，以减少对所用语言的依赖性。主要的客户端库包括 C++、Python 和 Lisp。 其他语言包括 Java、 Lua、.NET、EusLisp 和 R。 为此，开发了诸如 roscpp、rospy、roslisp、rosjava、 roslua、roscs、roseus、PhaROS、rosR 等客户端库。

URI：统一资源标识符（URI，Uniform Resource Identifier）是代表 Internet 上资源的唯一地址。该 URI 被用作Internet 协议中的标识符，是在 Internet 上所需的基本条件。

MD5：MD5（Message-Digest algorithm 5）是128位密码散列函数。它主要用于检查程序或文件的完整性，以查看它是否保持原样。在使用 ROS 消息的通信中，使用 MD5 来检查消息发送/接收的完整性。

RPC：远程过程调用（RPC，Remote Procedure Call）意味着远程（Remote）计算机上的程序调用（Call）另一台计算机中的子程序（Procedure）。这个利用 TCP/IP、IPX 等传输协议的技术在不需要程序员一一进行编程的情况下也能允许计算机在另一个地址空间通过远程控制运行函数或子程序。

XML：可扩展标记语言（XML，Extensible Markup Language）是 W3C 推荐用于创建其他特殊用途标记语言的通用标记语言。它是通过使用标签来指定数据结构的语言之一。在 ROS 中用于 `*.launch、*.urdf` 和 `package.xml` 等各个部分。

XMLRPC：XML-Remote Procedure Call（XMLRPC）是一种 RPC 协议，其编码形式采用 XML 编码格式，而传输方式采用既不保持连接状态、也不检查连接状态的请求和响应方式的 HTTP 协议。XMLRPC 是一个非常简单的约定，仅用于定义小数据类型或命令，所以它比较简单。有了这个特点，XMLRPC 非常轻便，支持多种编程语言，因此非常适合支持各种硬件和语言的 ROS。

TCP/IP：传输控制协议（TCP，Transmission Control Protocol）是一种传输控制协议，通常被称为 TCP/IP。从互联网协议层的角度来看，它基于 IP（Internet Protocol）且使用传输控制协议 TCP，以此保证数据传输，并按照发送顺序进行发送/接收。
TCPROS 消息和服务中使用的基于 TCP/IP 的消息方式称为 TCPROS，而 UDPROS 消息及服务中使用的基于 UDP 的消息方式称为 UDPROS。在 ROS 中，常用的是 TCPROS。

CMakeLists.txt：ROS 构建系统的 catkin 基本上使用了 CMake， 因此在功能包目录的 CMakeLists.txt 文件中描述了构建环境。

package.xml：包含功能包信息的 XML 文件 ，描述功能包名称、作者、许可证和依赖包。


节点管理器：为了统筹管理以上概念，系统当中需要有一个控制器使得所有节点有条不紊地执行，这就是 ROS 节点管理器（ROS Master）。ROS Master 通过远程过程调用（XMLRPC，XML-Remote Procedure Call，RPC）提供登记列表和对其他计算图表的查找功能，`roscore` 是它的运行命令，帮助 ROS 节点之间相互查找、建立连接，同时还为系统提供参数服务器，管理全局参数。ROS Master 就是一个管理者，没有它的话，节点将无法找到彼此，也无法交换消息或调用服务，整个系统将会瘫痪， 由此可见其在 ROS 系统中的重要性。
XMLRPC 是一种基于 HTTP 的协议，ROS Master 不与连接到 ROS Master 的节点保持连接。换句话说，节点只有在需要注册自己的信息或向其他节点发送请求信息时才能访问 ROS Master 并获取信息。通常情况下，不检查彼此的连接状态。由于这些特点，ROS 可用于非常大而复杂的环境。XMLRPC 也非常轻便，支持多种编程语言，使其非常适合支持各种硬件和语言的 ROS。

当启动ROS时，ROS Master 将获取用户设置的 `ROS_MASTER_URI` 变量中列出的 URI 地址和端口。除非另外设置，默认情况下，URI 地址使用当前的本地IP，端口使用11311。


![[ROS中的文件系统结构.png]]
文件系统：
1.  功能包（Package）：功能包是 ROS 软件中的基本单元，包含 ROS 节点、库、配置文件等。
2.  功能包清单（Package Manifest）：每个功能包都包含一个名为 package.xml 的功能包清单，用于记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等。
3.  元功能包（Meta Package）：组织多个用于同一目的的功能包。 例如一个 ROS 导航的元功能包中会包含建模、定位、导航等多个功能包。
4.  元功能包清单（Meta Package Manifest）：类似于功能包清单，不同之处在于元功能包清单中可能会包含运行时需要依赖的功能包或者声明一些引用的标签。
5.  消息（Message）类型：消息是 ROS 节点之间发布/订阅的通信信息，可以使用 ROS 提供的消息类型，也可以使用.msg 文件在功能包的 msg 文件夹下自定义所需要的消息类型。
6.  服务（Service）类型：服务类型定义了 ROS 客户端/服务器通信模型下的请求与应答数据类型，可以使用 ROS 系统提供的服务类型，也可以使用.srv 文件在功能包的 srv 文件夹中进行定义。
7.  代码（Code）：用来放置功能包节点源代码的文件夹。

![[ROS功能包的典型结构.png]]
功能包
上图是功能包的典型文件结构，这些文件夹的主要功能如下：
（1）config：放置功能包中的配置文件，由用户创建，文件名可以不同。
（2）include：放置功能包中需要用到的头文件。
（3）scripts：放置可以直接运行的 Python 脚本。
（4）src：放置需要编译的 C++ 代码。
（5）launch：放置功能包中的所有启动文件。
（6）msg：放置功能包自定义的消息类型。
（7）srv：放置功能包自定义的服务类型。
（8）action：放置功能包自定义的动作指令。
（9）CMakeLists.txt：编译器编译功能包的规则。
（10）package.xml：功能包清单。
`<build_depend></build_depend>` 标签定义了功能包中代码编译所依赖的其他功能包， 而 `<run_depend></run_depend>` 标签定义了功能包中可执行程序运行时所依赖的其他功能包。

功能包（package）是构成 ROS 的基本单元。ROS 应用程序是以功能包为单位开发的。功能包包括至少一个以上的节点或拥有用于运行其他功能包的节点的配置文件。它还包含功能包所需的所有文件，如用于运行各种进程的 ROS 依赖库、数据集和配置文件等。


元功能包
元功能包是一种特殊的功能包，只包含一个 package.xml 元功能包清单文件。它的主要作用是将多个功能包整合成为一个逻辑上独立的功能包，类似于功能包集合的概念。例如，导航元功能包包含 AMCL、DWA、EKF 和 map_server 等10余个功能包。
元功能包需要包含一个引用的标签如下：
```xml
<export> 
    <metapackage/> 
</export>
```

此外， 元功能包清单不需要 `<build_depend>` 标签声明编译过程依赖的其他功能包， 只需要使用 `<run_depend>` 标签声明功能包运行时依赖的其他功能包。

![[ROS社区资源的组织形式.png]]

ROS 的通信机制
ROS 是一个分布式框架，为用户提供多节点（进程）之间的通信服务，所有软件功能和工具都建立在这种分布式通信机制上，所以 ROS 的通信机制是最底层也是最核心的技术。

![[基于发布-订阅模型的话题通信机制.png]]
话题通信机制
话题在 ROS 中使用最为频繁，其通信模型也较为复杂：
1.  Talker 注册：Talker 启动，通过 1234 端口使用 RPC 向 ROS Master 注册发布者的信息，包含所发布消息的话题名；ROS Master 会将节点的注册信息加入注册列表中。
2.  Listener 注册：Listener 启动，同样通过 RPC 向 ROS Master 注册订阅者的信息，包含需要订阅的话题名。
3.  ROS Master 进行信息匹配：Master 根据 Listener 的订阅信息从注册列表中进行查找，如果没有找到匹配的发布者，则等待发布者的加入；如果找到匹配的发布者信息，则通过 RPC 向 Listener 发送 Talker 的 RPC 地址信息。
4.  Listener 发送连接请求：Listener 接收到 Master 发回的 Talker 地址信息，尝试通过 RPC 向 Talker 发送连接请求，传输订阅的话题名、消息类型以及通信协议（TCP/UDP）。
5.  Talker 确认连接请求：Talker 接收到 Listener 发送的连接请求后，继续通过 RPC 向 Listener 确认连接信息，其中包含自身的 TCP 地址信息。
6.  Listener 尝试与 Talker 建立网络连接：Listener 接收到确认信息后，使用 TCP 尝试与 Talker 建立网络连接。
7.  Talker 向 Listener 发布数据：成功建立连接后，Talker 开始向 Listener 发送话题消息数据。

从上面的分析中可以发现， 前五个步骤使用的通信协议都是 RPC， 最后发布数据的过程才使用到 TCP。
ROS Master 在节点建立连接的过程中起到了重要作用，但是并不参与节点之间最终的数据传输。
节点建立连接后，可以关掉 ROS Master，节点之间的数据传输并不会受到影响，但是其他节点也无法加入这两个节点之间的网络。

![[基于服务器-客户端的服务通信机制.png]]
服务通信机制
服务是一种带有应答的通信机制，与话题的通信相比，其减少了 Listener 与 Talker 之间的 RPC 通信：
1.  Talker 注册：Talker 启动，通过 1234 端口使用 RPC 向 ROS Master 注册发布者的信息，包含所提供的服务名；ROS Master 会将节点的注册信息加入注册列表中。
2.  Listener 注册：Listener 启动，同样通过 RPC 向 ROS Master 注册订阅者的信息，包含需要查找的服务名。
3.  ROS Master 进行信息匹配：Master 根据 Listener 的订阅信息从注册列表中进行查找，如果没有找到匹配的服务提供者，则等待该服务的提供者加入；如果找到匹配的服务提供者信息，则通过 RPC 向 Listener 发送 Talker 的 TCP 地址信息。
4.  Listener 与 Talker 建立网络连接：Listener 接收到确认信息后，使用 TCP 尝试与 Talker 建立网络连接，并且发送服务的请求数据。
5.  Talker 向 Listener 发布服务应答数据：Talker 接收到服务请求和参数后，开始执行服务功能，执行完成后，向 Listener 发送应答数据。

![[基于RPC的参数管理机制.png]]
参数管理机制
参数类似于 ROS 中的全局变量，由 ROS Master 进行管理，其通信机制较为简单，不涉及 TCP/UDP 的通信：
1.  Talker 设置变量
Talker 使用 RPC 向 ROS Master 发送参数设置数据，包含参数名和参数值；ROS Master 会将参数名和参 数值保存到参数列表中。
2.  Listener 查询参数值
Listener 通过 RPC 向 ROS Master 发送参数查找请求，包含所要查找的参数名。
3.  ROS Master 向 Listener 发送参数值
Master 根据 Listener 的查找请求从参数列表中进行查找， 查找到参数后， 使用 RPC 将参数值发送给 Listener。

这里需要注意的是，如果 Talker 向 Master 更新参数值，Listener 在不重新查询参数值的情况下是无法知晓参数值已经被更新的。所以在很多应用场景中，需要一种动态参数更新的机制。

![[话题与服务的区别.png]]
话题与服务的区别：
话题是 ROS 中基于发布/订阅模型的异步通信模式，这种方式将信息的产生和使用这两方解耦，常用于不断更新的、含有较少逻辑处理的数据通信；
服务多用于处理 ROS 中的同步通信，采用客户端/服务器模型，常用于数据量较小但有强逻辑处理的数据交换。
同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；
异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。 当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。

> 什么是节点？
> 话题和服务通信的异同点有哪些？
> ROS Master 在系统中的作用是什么？
> 话题通信中有哪七个步骤？
> 相比话题通信，服务通信少了哪几个步骤？
> ROS 参数管理时有没有用到 TCP/UDP 通信？

> 进程。
> 多对多节点&一对多节点；单向发送&双向应答；异步&同步；等等。
> Talker 注册，Listener 注册，ROS Master 根据 Listener 信息匹配，Listener 向 Talker 发送连接请求，Talker 向 Listener 确认连接请求，Listener 尝试网络连接 Talker，Talker 向 Listener 发送数据。
> Listener 向 Talker 发送连接请求，Talker 向 Listener 确认连接请求。
> 没有，用的是 RPC。